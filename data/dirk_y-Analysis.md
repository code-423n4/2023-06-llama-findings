# Quality Summary
Overall I would consider the quality of this codebase "high", especially considering the quality of the comments. Any key trade-offs/technical decisions are well highlighted with inline comments which makes it easy to determine what risks are acceptable and what are unacceptable. I would say that the trade-offs made have struck a good balance between gas usage and complexity vs protocol health. Functions are generally short and perform one action, and internal methods are well named and arranged thoughtfully in the source code.

# Auditing Approach
I approached this audit similarly to other audits, first starting with reading all the documentation and watching the provided video on high level architecture. I then focused on the Core contract and proceeded to branch out to the other periphery contracts over time. Any interesting thoughts or potential edge cases were noted down and then revisited later once I had a better understanding of the whole protocol. Any edge cases that were complex and that still appeared valid after another code/logic review were then confirmed by making changes to the existing test suite to induce the bug/unexpected behaviour.

# Architecture Feedback
Generally I feel like the architecture of Llama is fairly well laid out. Core functionality is split from Policy functionality, and Strategies are also self-contained. Having each component logically separate not only makes for easier reading as an auditor, but it also keeps purpose of each contract clear and minimises the number of entry points for users. Speaking of entry points, having all the key user entrypoints in the Core contract is ideal from a wallet security point of view; a user that interacts with a known, trusted address is usually happier than a user that has to interact with 3 different contract addresses to perform the same actions. From a high-level architecture point of view, I don't feel like there is anything that drastically needs changing.

# Mechanism Review
I can understand the reasoning for splitting policy holders from roles from permissions, however the trade-off between power and complexity is a difficult topic to navigate. On one hand, having these concepts nested as they are allows for the most powerful and complex use cases and doesn't restrict Llama instances to only basic use cases. However, on the other hand the complexity introduces risk, which is discussed further below. Assuming the risk is well understood and tolerated by the Llama org, I would say that the mechanism design is smart and clearly very powerful. However, my counter point to that would be, does anyone actually need this kind of complexity? Who needs this complexity or are you building for a future that may or may not exist?

# Risks
The most obvious risk to me is the centralisation risk of having the LlamaFactory contract governed by the Llama organisation. This centralisation means that no new Llama instances can be deployed without the permission of the Llama org. In the short term this is probably an acceptable risk, however long term this becomes more of an issue. What if the Llama org becomes insolvent or disbands? If an existing deployment becomes tainted or exploited due to bad permission/role management, how can a protocol that depends on Llama spin up a new instance?

The design of the protocol also introduces a tonne of risk vectors given the number of permutations of policy holders, role holders, and permissions. Managing all of these permutations and having a high level overview of who has what permissions is a dangerous game. Permission management is incredibly important for a product like Llama, so I would like to see a dapp or some other off-chain portal that gives a high level view of role allocations and permissions across an instance. This will help aid instances to stay healthy long term as more complexity is introduced over time (more holders, more roles, and more permissions).

Finally, as detailed in one of my findings, I believe allowing delegatecalls to non-whitelisted contracts is extremely dangerous and should be avoided. I can understand the motivation for delegatecalls to self-contained functionality in scripts like `LlamaGovernanceScript`, however this should be a whitelisted script (where the Llama org is the whitelister). By having the Llama org whitelist allowed scripts, the org can remain in control of the perception of the Llama product. Imagine if a Llama instance was exploited due to a malicious delegatecall. Not only would this impact the instance itself, but also the perception of other users and potential users of the Llama product.

### Time spent:
12 hours