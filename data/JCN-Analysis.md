*This analysis report is meant to accompany my Gas Optimizations Report submission. All insights will be given through the perspective of optimizing the codebase.*

When reviewing this code base I prioritized mitigating unnecessary `SLOAD`s and `SSTORE`s. The first optimizations I observed were instances that the Automated Report missed from the common `State variables should be cached in stack variables rather than re-reading them from storage` finding.

Next, I began analyzing functions which used `for loops`. `SLOAD`s and `SSTORE`s should always try to be avoided in loops. Unfortunately, when internal functions are invoked within loops, expensive storage operations that occur within those internal functions may go unnoticed. `LlamaPolicy.sol` had a few instances in which internal functions (that read and/or wrote to storage) were called within loops. It is important to note that while refactoring is needed to mitigate these instances, maintaining code readbility is something to consider. I found two methods of refactoring that could be used for this optimization, both of which I included in my report in order to demostrate the different alternatives to the sponsor. One method would be to refactor the internal function, which would also require refactxoring every other function that invokes the internal function. The other method would be to adopt the logic of the internal function into the state-mutating function that contains the for loop. The second option would slightly increase deployment costs since the bytecode would be larger due to the injected logic and the first method may hinder readability. 

My next approach was to analyze the `LlamaCore.sol` file. I noticed that the core functions in this contract invoke functions present in the `LlamaPolicy.sol` and `./src/strategy/*` files. I focused my attention on the strategy contracts with the intention to greatly improve gas costs via altering storage layout and/or mitigating storage operations. A major optimization I found, that was missed by the automated report, is to combine the `forceApprovalRole` and `forceDisapprovalRole` mappings into a single mapping of a struct. Doing so will help in multiple ways: 1. Both bools now occupy a single slot, thus will save a `Gsset (20000 gas)` for roles that can force an action to be approved AND for roles that can force an action to be disapproved. 2. The two mappings are accessed in functions that are called in `Llama.Core.sol`, which can save gas on storage reads since only one `cold` SLOAD would be needed when accessing both `forceApprovalRole` and `forceDisapprovalRole` in one call.

The third major optimization I found was in the `LlamaGovernanceScript.sol` file. The functions within this file were not diretly benchmarked and therefore only estimated gas savings were given. This is another optimization that can go seemingly unnoticed because it is a result of best practices being used to creating one internal function that can be re-used in multiple other functions. However, as shown in my report, some functions do not require all of the functionality of the internal function and this can result in an excessive external call.

The last optimization that relates to expensive operations (reading/writing storage & external calls) involves refactoring validation checks. There are 4 instances I found where the order of validation checks in functions can be rearranged to perform the checks that are least expensive (typically validating calldata & stack variables) first. This optimization is less impactful that the previous 3 since this would primarily save gas on unhappy paths (early reverts).

The other two optimizations in my report, although not dealing with storage, prove to save an impactful amount of gas per the benchmarked tests. I avoided including any other "bot-like findings" that are low impact, so as to respect the judges time since they would already have to sift through the automated report for valid findings.

### Time spent:
12 hours